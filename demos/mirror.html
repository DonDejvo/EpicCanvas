<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    	body {
    	    margin: 0;
            padding: 0;
        }
    </style>
 </head>
<body>
    <!-- dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.23/epiccanvas.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.23/primitives/sphere.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.23/primitives/cube.js" crossorigin='anonymous'></script>

<script>
  
const vsSource = `
attribute vec4 aVertexPosition;
attribute vec3 aVertexNormal;
 
uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelMatrix;
 
varying vec3 v_worldPosition;
varying vec3 v_worldNormal;
 
void main() {
  // Multiply the position by the matrix.
  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aVertexPosition;
 
  // send the view position to the fragment shader
  v_worldPosition = (uModelMatrix * aVertexPosition).xyz;
 
  // orient the normals and pass to the fragment shader
  v_worldNormal = mat3(uModelMatrix) * aVertexNormal.xyz;
}
    
`;

const fsSource = `

precision highp float;
 
// Passed in from the vertex shader.
varying vec3 v_worldPosition;
varying vec3 v_worldNormal;
 
// The texture.
uniform samplerCube uSampler;
 uniform mat4 uModelMatrix;
 
// The position of the camera
uniform vec3 uCameraPosition;


// Function to reverse a 3x3 rotation matrix by applying its transpose
mat3 inverseMatrix(mat3 rotationMatrix) {
    // Compute the transpose of the rotation matrix
    mat3 invMatrix = mat3(
        rotationMatrix[0][0], rotationMatrix[1][0], rotationMatrix[2][0], // Column 0
        rotationMatrix[0][1], rotationMatrix[1][1], rotationMatrix[2][1], // Column 1
        rotationMatrix[0][2], rotationMatrix[1][2], rotationMatrix[2][2]  // Column 2
    );
    
    return invMatrix ;
}
 
void main() {
  vec3 worldNormal = normalize(v_worldNormal);
  vec3 eyeToSurfaceDir = normalize(v_worldPosition - uCameraPosition);
  vec3 direction = reflect(eyeToSurfaceDir,worldNormal);
  mat3 invModelMatrix = inverseMatrix(mat3(uModelMatrix));
  vec3 direction2 = invModelMatrix * direction;
  gl_FragColor = textureCube(uSampler, direction2) ;
}

`;

//skybox
const vsSource2 = `
attribute vec4 aVertexPosition;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

varying vec3 vDirection;

void main() {
    // Only apply rotation part of modelViewMatrix (remove translation)
    mat4 viewRotation = mat4(mat3(uModelViewMatrix));

    vec4 direction = viewRotation * aVertexPosition;
    vDirection = direction.xyz;

    gl_Position = uProjectionMatrix * viewRotation * vec4(direction.xyz, 1.0);
}`;

const fsSource2 = `
precision highp float;
uniform samplerCube uCubeMap;
varying vec3 vDirection;

void main() {
    gl_FragColor = textureCube(uCubeMap, normalize(vDirection));
}`;



// Globals
let sphere, skybox, w, h, epicCanvas, program, program2, cubemap;



const loop = (t) => {
	rotateX(sphere, 0.01);
	rotateZ(sphere, Math.sin(t/1000)*0.01);
	epicCanvas.reloadBufferData(sphere);
    epicCanvas.clearColor = [0.7, 0.5, 0.8, 1.0];
    epicCanvas.clearScreen();
    epicCanvas.setCubeMap(cubemap);
    epicCanvas.drawShape(program, sphere);
    epicCanvas.setCubeMap(cubemap);
    epicCanvas.drawShape(program2, skybox);
    const error = epicCanvas.gl.getError();
    if (error !== epicCanvas.gl.NO_ERROR) {
        console.error("WebGL error in loop:", error);
    }
    epicCanvas.rotateMatrix(epicCanvas.matrices.viewMatrix, 0.01, [0,1,0]);
  epicCanvas.rotateMatrix(epicCanvas.matrices.modelMatrix, Math.sin(t/2000)*(-0.01), [1,0,0]);
  
  requestAnimationFrame(loop);
};

const main = async () => {
    try {
        // Create canvas
        const width = w = innerWidth;
        const height = h = innerHeight;
        epicCanvas = new EpicCanvas(width, height, "body");

        // Set up camera
        epicCanvas.lookAt([0, 0, 5], [0, 0, 0], [0, 1, 0]);
        epicCanvas.aspectRatio = w/h;
        epicCanvas.fieldOfView = Math.PI / 3
        
        // Create shader programs
        program = epicCanvas.makeProgram(vsSource, fsSource);
        program2 = epicCanvas.makeProgram(vsSource2, fsSource2);

        // Create a sphere
        sphere = Sphere(epicCanvas, 7);
        
        // creat skybox
        skybox = Cube(epicCanvas);
        scale(skybox, 50, 50, 50);
        epicCanvas.reloadBufferData(skybox);
        
        
        // load cube map
        const prefix = "https://raw.githubusercontent.com/paul-caron/EpicCanvas/refs/heads/master/assets/cubemaps/earth/";

        const URLs = [
prefix + "posx.jpg",
prefix + "negx.jpg",
prefix + "posy.jpg",
prefix + "negy.jpg",
prefix + "posz.jpg",
prefix + "negz.jpg",
        ];
        cubemap = await epicCanvas.loadCubeMap(URLs);

        // Check for WebGL errors
        const error = epicCanvas.gl.getError();
        if (error !== epicCanvas.gl.NO_ERROR) {
            console.error("WebGL error after initial render:", error);
        }

        // Start the loop
        requestAnimationFrame(loop);
    } catch (e) {
        console.error("Error in main:", e);
    }
};

onload = main;
</script>
</body>
</html>
