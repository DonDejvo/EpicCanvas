<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
        }
        canvas {
            
        }
        #log {
        	z-index: 2;
            position: absolute;
            top:0;
            left:0;
            color:white;
        }
    </style>
</head>
<body>
	<div id="log"></div>
    <!-- dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/epiccanvas.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/primitives/squaremesh.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/primitives/icosahedron.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/primitives/tree.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/shaders/vertexDiffuseShadow.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/shaders/fragmentDiffuseShadow.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/shaders/vertexDepth.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v2.0.0-beta-26/shaders/fragmentDepth.js" crossorigin='anonymous'></script>

    <script>
        //globals
        let floor, tree, moon, model, epicCanvas, program, shadowProgram, depthProgram;

        let shadowMapSize = 4096
        let depthFramebuffer;
        let depthTexture;
        
        let debuglog, oldt=0
        
        function depthMappingScene(){
        	epicCanvas.setViewport(0, 0, shadowMapSize, shadowMapSize);
            epicCanvas.clearScreen();
            epicCanvas.drawShape(depthProgram, model);
            epicCanvas.drawShape(depthProgram, moon);
            epicCanvas.drawShape(depthProgram, tree);
        }

        function render(t) {
        	let dt = t-oldt;
			// fps limiter
            if(1/dt*1000 > 95){
            	requestAnimationFrame(render);
                return;
            }
            oldt = t;
            try {
            	// Depth Mapping, Option 1: (reusing framebuffer)
                epicCanvas.bindFramebuffer(depthFramebuffer);
                depthMappingScene();
                epicCanvas.unbindFramebuffer();
                
                // Depth Mapping, Option 2:
                //epicCanvas.renderToDepthTexture(depthTexture, shadowMapSize, shadowMapSize, depthMappingScene);
                
                // final render of models
                epicCanvas.setViewport(0, 0, epicCanvas.canvas.width, epicCanvas.canvas.height);
                epicCanvas.clearScreen();
                epicCanvas.setDepthTexture(depthTexture);
                epicCanvas.drawShape(shadowProgram, model);
                epicCanvas.drawShape(shadowProgram, floor);
                epicCanvas.drawShape(shadowProgram, moon);
                epicCanvas.drawShape(shadowProgram, tree);
                
                // text debug display
                const [x,y,z] = epicCanvas.getWorldPosition(moon).map(wp=>wp.toFixed(2))
                debuglog = debuglog? debuglog : document.querySelector("#log");
                debuglog.innerText= "moon pos:"+x+","+y+","+z+", fps:"+(1/dt*1000).toFixed(2)
                
                //update models
                epicCanvas.rotateModelMatrix(model, dt*0.001, [0,1,0])
                epicCanvas.rotateModelMatrix(moon, dt*0.002, [0,1,0])
                epicCanvas.rotateShapeOnItself(moon, dt*-0.002, [0,1,0])
                epicCanvas.rotateShapeOnItself(moon, dt*-0.002, [1,0,0])
                epicCanvas.makeShapeLookAt(model, epicCanvas.getWorldPosition(moon).slice(0,3))
            

                //loop
                requestAnimationFrame(render);
            } catch(e) {
                alert(e)
            }
        }
        
        

        const main = async () => {
            try {
                // create canvas
                const width = innerWidth;
                const height = innerHeight;
                epicCanvas = new EpicCanvas(width,height,"body");

                // create variety of objects
                floor = SquareMesh(epicCanvas);
                floor.mode = epicCanvas.gl.LINE_LOOP;
                epicCanvas.scaleModelMatrix(floor, [7,7,7])
                epicCanvas.rotateModelMatrix(floor, -Math.PI/2, [1,0,0]);
                epicCanvas.translateModelMatrix(floor, [0,-0.6,0])

                moon = Icosahedron(epicCanvas);
                epicCanvas.scaleModelMatrix(moon, [1,2.6,1])
                epicCanvas.translateModelMatrix(moon, [-1,2,2])

                tree = Tree(epicCanvas, 0.2, 4, 3, 3)
                tree.colors = tree.colors.map(_=>1)
                center(tree)
                epicCanvas.rotateModelMatrix(tree, -Math.PI/2,[1,0,0]);
                epicCanvas.translateModelMatrix(tree, [0,-0.6,0])
                epicCanvas.reloadBufferData(tree)

                // set clear color 
                epicCanvas.clearColor = [0.1,0.2,0.25,1.0];

                // setup the camera position, lookat center point, up vector.
                epicCanvas.lookAt([0,0.5,8], [0,0.5,0], [0,1,0]);
                epicCanvas.fieldOfView = Math.PI/3
                epicCanvas.aspectRatio = width/height;

                // create shader program
                shadowProgram = epicCanvas.makeProgram(vsDiffuseShadow, fsDiffuseShadow);
                depthProgram = epicCanvas.makeProgram(vsDepth, fsDepth);

                //setup some lighting of 3 types
                epicCanvas.ambientColor = [0.5,0.2,0.1];
                epicCanvas.directionalColor = [0.2,0.75,0.9]
                epicCanvas.directionalVector =[0,0.7,0.7] //direction the light comes from, should be normalized
                
                //depth tools
                depthTexture = epicCanvas.createDepthTexture(shadowMapSize, shadowMapSize)
                depthFramebuffer = epicCanvas.createDepthFramebuffer(depthTexture);

                // Light matrices
                // the difference between the two lightPos and target vector should be paralel to directional light vector
                const lightPos =  [0, 5, 5]  // should be parallel to epicCanvas.directionalVector, ideally in a nice place to project close to the model
                const target = [0, 0, 0]; //this vector should be in parallel to epicCanvas.directionalVector
                const up = [0, 1, 0]
                epicCanvas.setLightViewMatrix(lightPos, target, up)
                epicCanvas.setLightProjectionMatrix(10, 10, 0.1, 20)
                
                const url = "https://raw.githubusercontent.com/paul-caron/EpicCanvas/master/models/blackimp/black_imp.stl"
                model = await epicCanvas.loadSTL(url);
                center(model);
                rotateX(model, -Math.PI/2)
                rotateY(model, Math.PI)
                scaleToUnitSize(model)
                epicCanvas.reloadBufferData(model);
                epicCanvas.translateModelMatrix(model, [0,0,-4])
                epicCanvas.moveShapeTo(model, [0,0,-4])
                
                requestAnimationFrame(render);
            } catch(e) {
                alert("error in main:"+e);
            }
        }

        onload = main;
    </script>
</body>
</html>
