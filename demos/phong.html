<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    	*{
    	margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    canvas {
    	width: 100%;
    }
    </style>
 </head>
<body>
    <!-- dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.26/epiccanvas.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.25/primitives/sphere.js" crossorigin='anonymous'></script>
        <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.25/primitives/cube.js" crossorigin='anonymous'></script>
        <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.25/primitives/dodecahedron.js" crossorigin='anonymous'></script>
        <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.25/primitives/cylinder.js" crossorigin='anonymous'></script>
    <script src="https://cdn.jsdelivr.net/gh/paul-caron/EpicCanvas@v1.16.25/primitives/square.js" crossorigin='anonymous'></script>
  <script>
const vsSource =`
attribute vec4 aVertexPosition;
attribute vec4 aVertexNormal;
attribute vec4 aVertexColor;

uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uNormalMatrix;
uniform vec3 uCameraPosition;

varying vec3 vNormal;
varying vec3 vWorldPosition;
varying vec4 vColor;
varying vec3 vViewDirection;

void main() {
    vec4 worldPosition = uModelMatrix * aVertexPosition;
    vWorldPosition = worldPosition.xyz;
    vNormal = normalize(uNormalMatrix * aVertexNormal).xyz;
    vViewDirection = normalize(uCameraPosition - worldPosition.xyz);
    vColor = aVertexColor;
    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
}

`;

const fsSource = `
precision mediump float;

varying vec3 vNormal;
varying vec3 vWorldPosition;
varying vec4 vColor;
varying vec3 vViewDirection;

uniform vec3 pointLightPosition;
uniform vec3 pointLightColor;
uniform vec3 directionalLightColor;
uniform vec3 directionalVector;
uniform vec3 ambientLight;
//uniform float shininess;

void main() {
	float shininess = 22.0;
    vec3 normal = normalize(vNormal);
    vec3 lightDir = normalize(pointLightPosition - vWorldPosition);
    vec3 reflectDir = reflect(-lightDir, normal);
    vec3 viewDir = normalize(vViewDirection);

    // Ambient
    vec3 ambient = ambientLight * vColor.rgb;
    
    // Directional
    float directionalLightIntensity=max(dot(normal, directionalVector),0.0);
    vec3 directional = directionalLightIntensity * directionalLightColor * vColor.rgb;

    // Point Light Diffuse
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = pointLightColor * diff * vColor.rgb;

    // Point Light Specular
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
    vec3 specular = pointLightColor * spec * vColor.rgb;

    // Combine
    vec3 finalColor = ambient + diffuse + specular + directional;
    gl_FragColor = vec4(finalColor, vColor.a);
}
`


//globals
let s, s2, model, epicCanvas, program;

//draw loop
const loop = (t) => {
  //clear screen
  epicCanvas.clearScreen();
  //draw
  epicCanvas.drawShape(program, model);
  epicCanvas.drawShape(program, s);
  epicCanvas.drawShape(program, s2);
  epicCanvas.rotateMatrix(epicCanvas.matrices.viewMatrix, -0.01, [0,1,0]);
  epicCanvas.rotateMatrix(epicCanvas.matrices.modelMatrix, 0.01, [0,1,0]);
  //loop
  requestAnimationFrame(loop);
}


const main = () => {
  // create canvas
  const width = innerWidth*4;
  const height = innerHeight*4;
  epicCanvas = new EpicCanvas(width,height,"body");

  // set clear color and clear the canvas
  epicCanvas.clearColor = [0,0,0,1.0];
  epicCanvas.clearScreen();

  // setup the camera position, lookat center point, up vector.
  epicCanvas.lookAt([0,0,8], [0,0,0], [0,1,0]);
  epicCanvas.aspectRatio = innerWidth/innerHeight;
  epicCanvas.fieldOfView = Math.PI /2;
  
  // create shader program
  program = epicCanvas.makeProgram(vsSource, fsSource);

  // create background
  s = Square(epicCanvas);
  scale(s, 15, 15,15);
  translateZ(s,-8);
  s.colors = s.colors.map(_=>1.0);
  epicCanvas.reloadBufferData(s);
  
  // create floor
   s2 = Square(epicCanvas);
   rotateX(s2, -Math.PI/2);
   rotateY(s2, -Math.PI/2);
   scale(s2, 5,5,5)
   translateY(s2, -3);
   s2.colors = s2.colors.map(_=>1.0);
  epicCanvas.reloadBufferData(s2);
  
  //setup some lighting of 3 types
epicCanvas.ambientColor = [0.25,0.25,0.125];
//epicCanvas.directionalColor = [0.5,0.5,1.0]
//epicCanvas.directionalVector = [0.7,0.7,0] //direction the light comes from
epicCanvas.pointLightColor = [0.2,0.25,0.65]
epicCanvas.pointLightPosition = [0,1.5,5]


  model = Sphere(epicCanvas,300);
  model.colors = model.vertices.map(_=>1.0);
  scale(model, 1,2,1);
  epicCanvas.reloadBufferData(model);
      //loop draw
      requestAnimationFrame(loop);
}


onload = main;




  </script>
</body>
</html>
